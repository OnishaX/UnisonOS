var colors = require('colors');
var fs = require("fs");
const { resolve } = require('path');
var _path = require("path");
const exec = require('child_process').exec;

var common = {};

common.ajax = {};
common.data = {};
common.time = {};
common.utils = {};
common.fs = {};
common.array = {};
common.error = {};

common.time.data = {};

common.data.logs = [];

common._allFunctionsLoaded = false;

// common.time Data
common.time.data.validformats = [
    "DD-MM-YYYY HH:II:SS:MS AMPM",
    "DD-MM-YYYY HH:II:SS:MS",
    // Breaking Full Formate
    "DD-MM-YYYY",
    "HH:II:SS:MS AMPM",
    "HH:II:SS:MS",
    // Breaking "DD-MM-YYYY"
    "DD-MM",
    "DD-YYYY",
    "MM-YYYY",
    // Breaking "HH:II:SS:MS"
    "HH:II:SS AMPM",
    "HH:II:SS",
    "HH:II",
    "HH:II AMPM",
    "II:SS",
    "II:SS AMPM",
    "HH:SS",
    "HH:SS AMPM",
    "HH:MS",
    "HH:MS AMPM",
    "II:MS",
    "II:MS AMPM",
    "SS:MS",
    "SS:MS AMPM",
    // One Code Formates
    "DD",
    "MM",
    "YYYY",
    "HH",
    "II",
    "SS",
    "MS",
    "AMPM",
];


// common.time Obj
common.time.getTime = (dateMain = new Date(), format = null, hourFormat = "24") => {

    returnStr = "";

    dateMain = dateMain == "" ? new Date() : dateMain
    format = format == "" ? null : format
    hourFormat = hourFormat == "" ? "24" : hourFormat

    // Gathing Data
    date = dateMain.getDate();
    month = dateMain.getMonth() + 1;
    year = dateMain.getFullYear();
    hour = dateMain.getHours();
    minute = dateMain.getMinutes();
    second = dateMain.getSeconds();
    milisecond = dateMain.getMilliseconds();
    if (hourFormat == "24") {
        ampm = hour >= 12 ? 'pm' : 'am';
        hour = hour % 12;
        hour = hour ? hour : 12;
        ampm = ampm.toUpperCase()
    }

    // Fixing Two Nubmers Problem
    if (format == null) {
        date = date < 10 ? `0${date}` : date;
        month = month < 10 ? `0${month}` : month;
        hour = hour < 10 ? `0${hour}` : hour;
        minute = minute < 10 ? `0${minute}` : minute;
        second = second < 10 ? `0${second}` : second;
        milisecond = milisecond < 100 ? `0${milisecond}` : milisecond;
        milisecond = milisecond < 10 ? `00${milisecond}` : milisecond;
    }


    if (format != null) {
        if (common.time.data.validformats.includes(format)) {

            returnStr = common.time.formatTime(dateMain, format, hourFormat)

        } else {
            common.error.raise("Invalid Format. Please Choose Any Valid Date&Time Format.")
        }
    } else {
        returnStr = `${date}-${month}-${year} ${hour}:${minute}:${second}:${milisecond}`;
    }

    return returnStr;
}

common.time.formatTime = (dateMain = new Date(), format = "DD-MM-YYYY HH:II:SS:MS", hourFormat = "24") => {

    // DD->Date
    // MM->Month
    // YYYY->Year

    // HH->Hour
    // II->minute 
    // SS->Second 
    // MS->MiliSecond

    // FullFormat:
    // DD-MM-YYYY HH:II:SS:MS


    FullFormat = "DD-MM-YYYY HH:II:SS:MS AMPM";
    returnStr = "";

    dateMain = dateMain == "" ? new Date() : dateMain
    format = format == "" ? FullFormat : format
    hourFormat = hourFormat == "" ? "24" : hourFormat


    // Gathing Data
    date = dateMain.getDate();
    month = dateMain.getMonth() + 1;
    year = dateMain.getFullYear();
    hour = dateMain.getHours();
    minute = dateMain.getMinutes();
    second = dateMain.getSeconds();
    milisecond = dateMain.getMilliseconds();
    if (hourFormat == "24") {
        ampm = hour >= 12 ? 'pm' : 'am';
        hour = hour % 12;
        hour = hour ? hour : 12;
        ampm = ampm.toUpperCase()
    }

    // Fixing Two Nubmers Problem
    date = date < 10 ? `0${date}` : date;
    month = month < 10 ? `0${month}` : month;
    hour = hour < 10 ? `0${hour}` : hour;
    minute = minute < 10 ? `0${minute}` : minute;
    second = second < 10 ? `0${second}` : second;
    milisecond = milisecond < 100 ? `0${milisecond}` : milisecond;
    milisecond = milisecond < 10 ? `00${milisecond}` : milisecond;


    if (common.time.data.validformats.includes(format)) {

        if (format == "DD-MM-YYYY HH:II:SS:MS AMPM") {
            returnStr = `${date}-${month}-${year} ${hour}:${minute}:${second}:${milisecond} ${ampm}`;
        } else if (format == "DD-MM-YYYY HH:II:SS:MS") {
            returnStr = `${date}-${month}-${year} ${hour}:${minute}:${second}:${milisecond}`;
        } else if (format == "DD-MM-YYYY") {
            returnStr = `${date}-${month}-${year}`;
        } else if (format == "HH:II:SS:MS AMPM") {
            returnStr = `${hour}:${minute}:${second}:${milisecond} ${ampm}`;
        } else if (format == "HH:II:SS:MS") {
            returnStr = `${hour}:${minute}:${second}:${milisecond}`;
        } else if (format == "DD-MM") {
            returnStr = `${date}-${month}`;
        } else if (format == "DD-YYYY") {
            returnStr = `${date}-${year}`;
        } else if (format == "MM-YYYY") {
            returnStr = `${month}-${year}`;
        } else if (format == "HH:II:SS AMPM") {
            returnStr = `${hour}:${minute}:${second} ${ampm}`;
        } else if (format == "HH:II:SS") {
            returnStr = `${hour}:${minute}:${second}`;
        } else if (format == "HH:II") {
            returnStr = `${hour}:${minute}`;
        } else if (format == "HH:II AMPM") {
            returnStr = `${hour}:${minute} ${ampm}`;
        } else if (format == "II:SS") {
            returnStr = `${minute}:${second}`;
        } else if (format == "II:SS AMPM") {
            returnStr = `${minute}:${second} ${ampm}`;
        } else if (format == "HH:SS") {
            returnStr = `${hour}:${second}`;
        } else if (format == "HH:SS AMPM") {
            returnStr = `${hour}:${second} ${ampm}`;
        } else if (format == "HH:MS") {
            returnStr = `${hour}:${milisecond}`;
        } else if (format == "HH:MS AMPM") {
            returnStr = `${hour}:${milisecond} ${ampm}`;
        } else if (format == "II:MS") {
            returnStr = `${minute}:${milisecond}`;
        } else if (format == "II:MS AMPM") {
            returnStr = `${minute}:${milisecond} ${ampm}`;
        } else if (format == "SS:MS") {
            returnStr = `${second}:${milisecond}`;
        } else if (format == "SS:MS AMPM") {
            returnStr = `${second}:${milisecond} ${ampm}`;
        } else if (format == "DD") {
            returnStr = `${date}`;
        } else if (format == "MM") {
            returnStr = `${month}`;
        } else if (format == "YYYY") {
            returnStr = `${year}`;
        } else if (format == "HH") {
            returnStr = `${hour}`;
        } else if (format == "II") {
            returnStr = `${minute}`;
        } else if (format == "SS") {
            returnStr = `${second}`;
        } else if (format == "MS") {
            returnStr = `${milisecond}`;
        } else if (format == "AMPM") {
            returnStr = `${ampm}`;
        }

    } else {
        common.error.raise("Invalid Format. Please Choose Any Valid Date&Time Format.")
    }

    return returnStr;

}

// error obj
common.error.raise = (data, dataLog = true) => {
    if (data == null || data == undefined) return;

    console.error(data)

    if (dataLog == true) {
        common.log(data)
    }
}

// common.log to log data into common.data.log
common.log = (log = null) => {

    let obj = {
        log: log,
        time: common.time.getTime()
    };

    common.data.logs.push(obj)
}

// common.ajax Obj
common.ajax.post = (target = null, postData = null, callback = null, log = true) => {

    $.post(target, postData, (data, status) => {
        if (typeof (callback) == "function") {
            callback(data, status)

            if (log) {
                common.log({
                    target: target,
                    postData: postData,
                    callback: callback,
                    callbackData: {
                        data: data,
                        status: status
                    }
                });
            }

        } else {
            common.error.raise(`"callback" parameter Must be a Function.`)
        }
    })

    return null;
}

common.ajax.asyncPost = (target = null, postData = null, log = true) => {
    return new Promise((resolve, reject) => {
        $.post(target, postData, (data, status) => {
            resolve({ data: data, status: status })

            if (log) {
                common.log({
                    target: target,
                    postData: postData,
                    callbackData: {
                        data: data,
                        status: status
                    }
                });
            }
        })
    })

}

// common.utils Obj
common.utils.randomNumber = (min = 0, max = 1000) => {
    return parseInt(Math.random() * (max - min) + min);
}

common.utils.randomToken = (length = 10) => {
    var a = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_".split("");
    var b = [];
    for (var i = 0; i < length; i++) {
        var j = (Math.random() * (a.length - 1)).toFixed(0);
        b[i] = a[j];
    }
    return b.join("");
}

common.utils.delayer = (t = 1000) => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(t);
        }, t);
    })
}

// common.array Obj
common.array.removeElementFromArray = (arr, value) => {
    var index = arr.indexOf(value);
    if (index > -1) {
        arr.splice(index, 1);
    }
    common.log({
        func: common.array.removeElementFromArray,
        data: {
            perameters: {
                arr: arr,
                value: value
            },
            returnData: {
                arr: arr
            }
        }
    })

    return arr;
}

common.array.removeElementsFromArray = (arr, value) => {
    var i = 0;
    while (i < arr.length) {
        if (arr[i] === value) {
            arr.splice(i, 1);
        } else {
            ++i;
        }
    }
    common.log({
        func: common.array.removeElementFromArray,
        data: {
            perameters: {
                arr: arr,
                value: value
            },
            returnData: {
                arr: arr
            }
        }
    })

    return arr;
}

// common.fs for file Systems Operations
common.fs.readFile = (filePath, encoding = 'utf-8') => {
    if (typeof (filePath) == "object") {
        return new Promise(async (resolve, reject) => {
            this.resolvedDataArr = [];
            for (let i = 0; i < filePath.length; i++) {
                this.resolvedDataArr.push(await common.fs.readFile(filePath[i], encoding));
            }
            resolve(this.resolvedDataArr);
        })
    } else {
        if (common.fs.isExist(filePath)) {

            return new Promise((resolve, reject) => {
                path = filePath
                fs.readFile(filePath, encoding, (err, data) => {
                    if (err) return resolve({ status: "error", err: err });
                    this.resolvedData = { data: data, err: err };
                    common.log({
                        func: common.fs.readFile,
                        data: {
                            path: filePath,
                            encoding: encoding,
                            resolved: this.resolvedData
                        }
                    })
                    resolve(this.resolvedData);
                })
            })

        } else {
            common.error.raise(`Path Does Not Exist at "${filePath}"`)
        }
    }

}

common.fs.writeFile = (filePath, data = null) => {
    if (typeof (filePath) == "object" && (typeof (data) != "object" || data == null)) {
        data = [];
        for (let i = 0; i < filePath.length; i++) {
            data.push("");
        }
    }
    if (typeof (filePath) == "object" && typeof (data) == "object") {
        return new Promise(async (resolve, reject) => {
            this.resolvedDataArr = [];
            for (let i = 0; i < filePath.length; i++) {
                this.resolvedDataArr.push(await common.fs.writeFile(filePath[i], data[i]));
            }
            resolve(this.resolvedDataArr);
        })
    } else {
        if (data == null) {
            data = "";
        }
        if (common.fs.isExist(filePath)) {

            return new Promise((resolve, reject) => {
                path = filePath

                fs.writeFile(filePath, data, (err) => {
                    this.resolvedData = { err: err }
                    common.log({
                        func: common.fs.writeFile,
                        data: {
                            path: filePath,
                            data: data,
                            resolved: this.resolvedData
                        }
                    })
                    resolve(this.resolvedData);
                })
            })

        } else {
            common.error.raise(`Path Does Not Exist at "${filePath}"`)
        }
    }
}

common.fs.createFile = (path, content = null) => {
    if (typeof (path) == "object" && (typeof (content) != "object" || content == null)) {
        content = [];
        for (let i = 0; i < path.length; i++) {
            content.push("");
        }
    }
    if (typeof (path) == "object" && typeof (content) == "object") {
        return new Promise(async (resolve, reject) => {
            this.resolvedDataArr = [];
            for (let i = 0; i < path.length; i++) {
                this.resolvedDataArr.push(await common.fs.createFile(path[i], content[i]));
            }
            resolve(this.resolvedDataArr);
        })
    } else {
        if (content == null) {
            content = "";
        }
        return new Promise((resolve, reject) => {
            path = path
            fs.appendFile(path, content, (err) => {
                this.resolvedData = { err: err }
                common.log({
                    func: common.fs.createFile,
                    data: {
                        path: path,
                        content: content,
                        resolved: this.resolvedData
                    }
                })
                resolve(this.resolvedData);
            })
        })
    }
}

common.fs.deleteFile = (path) => {
    if (typeof (path) == "object") {
        return new Promise(async (resolve, reject) => {
            this.resolvedDataArr = [];
            for (let i = 0; i < path.length; i++) {
                this.resolvedDataArr.push(await common.fs.deleteFile(path[i]));
            }
            resolve(this.resolvedDataArr);
        })
    } else {
        if (common.fs.isExist(path)) {

            return new Promise((resolve, reject) => {
                path = path
                fs.unlink(path, (err) => {
                    this.resolvedData = { err }
                    common.log({
                        func: common.fs.deleteFile,
                        data: {
                            path: path,
                            resolved: this.resolvedData
                        }
                    })
                    resolve(this.resolvedData)
                })
            })
        } else {
            common.error.raise(`Path Does Not Exist at "${path}"`)
        }
    }
}

common.fs.createDir = (path, options = { recursive: true }) => {
    if (typeof (path) == "object") {
        return new Promise(async (resolve, reject) => {
            this.resolvedDataArr = [];
            for (let i = 0; i < path.length; i++) {
                this.resolvedDataArr.push(await common.fs.createDir(path[i], options));
            }
            resolve(this.resolvedDataArr);
        })
    } else {
        return new Promise((resolve, reject) => {
            path = path
            fs.mkdir(path, options, (err) => {
                this.resolvedData = { err }
                common.log({
                    func: common.fs.createDir,
                    data: {
                        path: path,
                        resolved: this.resolvedData
                    }
                })
                resolve(this.resolvedData)
            })
        })
    }
}

common.fs.getFileNames = (path) => {
    if (common.fs.isExist(path)) {
        if (typeof (path) == "object") {
            return new Promise(async (resolve, reject) => {
                this.resolvedDataArr = [];
                for (let i = 0; i < path.length; i++) {
                    this.resolvedDataArr.push(await common.fs.getFileNames(path[i]));
                }
                resolve(this.resolvedDataArr);
            })
        } else {
            return new Promise((resolve, reject) => {
                path = path
                fs.readdir(path, (err, files) => {
                    if (err) return resolve({ status: "error", err: err });
                    try {
                        let resolvedData = {
                            err: err,
                            filesLength: files.length
                        };
                        let resolvedFiles = [];

                        files.forEach(async (file) => {

                            let toBeResolved = {};

                            try {
                                toBeResolved.fileName = file;
                                let state = fs.statSync(_path.join(path, file))
                                toBeResolved.state = state;
                                toBeResolved.isDir = state.isDirectory();
                                toBeResolved.path = _path.join(path, file)
                                resolvedFiles.push(toBeResolved);
                            } catch (e) { }

                        })

                        resolvedData.files = resolvedFiles;

                        common.log({
                            func: common.fs.getFileNames,
                            data: {
                                path: path,
                                resolved: resolvedData
                            }
                        })
                        resolve(resolvedData);
                    } catch (e) {
                        common.error.raise(e)
                    }
                })
            })
        }
    } else {
        common.error.raise(`Path Does Not Exist at "${path}"`)
    }
}

common.fs.isExist = (path) => {
    return new Promise((resolve) => {
        return fs.exists(path, (result) => {
            resolve(result)
        });
    })
}

common.fs.deleteDir = async (path) => {
    if (typeof (path) == "object") {
        return new Promise(async (resolve, reject) => {
            this.resolvedDataArr = [];
            for (let i = 0; i < path.length; i++) {
                this.resolvedDataArr.push(await common.fs.deleteDir(path[i]));
            }
            resolve(this.resolvedDataArr);
        })
    }
    if (common.fs.isExist(path)) {
        if ((await common.fs.getFileNames(path)).filesLength == 0) {
            // Directory Is empty

            return new Promise((resolve, reject) => {
                fs.rmdir(path, (err) => {
                    this.resolvedData = { err: err };
                    resolve(this.resolvedData)
                    common.log({
                        func: common.fs.deleteDir,
                        data: {
                            path: path,
                            resolved: this.resolvedData
                        }
                    })
                    resolve(this.resolvedData)
                })
            })

        } else {
            // Directory Is Filled With Files
            return new Promise(async (resolve, reject) => {
                // Removing All Files and Folders
                allFiles = await common.fs.getFileNames(path)

                if (allFiles.files.length > 0) {
                    for (let i = 0; i < allFiles.files.length; i++) {
                        oneFileName = _path.join(path, allFiles.files[i].fileName);
                        oneFile = allFiles.files[i];

                        if (oneFile.state.isDirectory()) {
                            await common.fs.deleteDir(oneFile.path);
                        } else {
                            await common.fs.deleteFile(oneFile.path);
                        }
                    }
                }
                // Deleting Empty Directory
                resolve(await common.fs.deleteDir(path));

            })
        }
    } else {
        common.error.raise(`Path Does Not Exist at "${path}"`)
    }
};

common.fs.fileLineCount = async (filePath) => {
    return new Promise((resolve, reject) => {
        exec(`wc ${filePath}`, function (error, results) {
            if (error) throw error
        });
    });
};


module.exports = common;
